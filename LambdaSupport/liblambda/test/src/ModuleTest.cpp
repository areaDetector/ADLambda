/*
 * (c) Copyright 2014-2015 DESY, Yuelong Yu <yuelong.yu@desy.de>
 *
 * This file is part of FS-DS detector library.
 *
 * This software is free: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this software.  If not, see <http://www.gnu.org/licenses/>.
 *************************************************************************
 *     Author: Yuelong Yu <yuelong.yu@desy.de>
 */

#include <LambdaModule.h>
#include <LambdaConfigReader.h>
#include <NetworkInterface.h>
#include <MockNetworkImplementation.h>
#include <FilesOperation.h>

#include "ModuleTest.h"
#include "CheckEquality.h"

namespace DetUnitTestNS
{
    CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(ModuleTest,"AllTest");

    
    void ModuleTest::setUp()
    {
        
        m_bMultiLink = true;
        m_strFilePath = string("./filetest");
        m_upConfig = std::unique_ptr<LambdaConfigReader>(new LambdaConfigReader(m_strFilePath));
        this->ReadConfig(false,"");
        
         m_spNetImp = std::shared_ptr<NetworkImplementation>(new NetworkTCPImplementation(m_strTCPIPAddress,m_shTCPPortNo));
        
        m_spNetInt = std::shared_ptr<NetworkInterface>(
            new NetworkTCPInterface(m_spNetImp.get()));

        m_upFileOp = std::unique_ptr<FileOperation>(new FileReader());
        m_upCheckEqual = std::unique_ptr<CheckEquality>(new CheckEquality());

        m_upModule = std::unique_ptr<LambdaModule>(new LambdaModule(m_strModuleID,m_spNetInt.get(),m_bMultiLink,m_vshCurrentChips,m_stDetData,m_vstChipData));
       
        
        m_vchCmd.resize(COMMAND_LENGTH,0x00);
    }
    
    void ModuleTest::tearDown()
    {
        m_upModule.reset();
        m_upConfig.reset();
        m_upFileOp.reset();
        m_upCheckEqual.reset();
    }
  
    void ModuleTest::TestInit()
    {
        // m_upModule = std::unique_ptr<LambdaModule>(new LambdaModule(m_strModuleID,m_spNetInt.get(),m_bMultiLink,m_vshCurrentChips,m_stDetData,m_vstChipData));
        vector<char> vchData = m_spNetImp->GetData();

        //get reference data from local file
        string strRefFile = m_strFilePath+string("/init_test.txt");
        m_upFileOp->SetFilePath(strRefFile);
        m_upFileOp->OpenFile(false);
        vector<string> vstrRefData = m_upFileOp->ReadDataFromFile();
        m_upFileOp->CloseFile();

        vector<char> vchRefData;
        for(auto it=vstrRefData.begin();it!=vstrRefData.end();it++)
            vchRefData.push_back(atoi((*it).c_str()));

        //cout<<vchRefData.size()<<"|"<<vstrRefData.size()<<"|"<<vchData.size()<<endl;

        //check data size correctness
        CPPUNIT_ASSERT(vchRefData.size()==vchData.size());

        //check if data is the same
        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
        
        m_spNetImp->ClearData();
    }
    
    void ModuleTest::TestShutterTime()
    {
        m_spNetImp->ClearData();
        
        double dTime = 100;
        m_upModule->WriteShutterTime(dTime);
                
        vector<char> vchRefData = {0x00,0xf0,0x46,0x00,0x00,0x00,0x00,0x00
                                 ,0x98,0x96,0x80,0x00,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();

        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
        
    }
    
    void ModuleTest::TestDelayTime()
    {
        
    }
    
    void ModuleTest::TestTriggerMode()
    {
        m_spNetImp->ClearData();
        
        short shTrig = 1;
        m_upModule->WriteTriggerMode(shTrig);
        
        vector<char> vchRefData = {0x00,0xf0,0x48,0x01,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();
        // cout<<"trigger:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
    }
    
    void ModuleTest::TestImageNumbers()
    {
        m_spNetImp->ClearData();
        
        long lImgNo = 100000;
        
        m_upModule->WriteImageNumbers(lImgNo);
        
        vector<char> vchRefData = {0x00,0xf0,0x47,0x01,0x86,0xa0,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();
        // cout<<"image:";
        
        //     for(int i=0;i<vchData.size();i++)
        //         printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
    }
    
    void ModuleTest::TestEnergyThreshold()
    {
         m_spNetImp->ClearData();
        
         int nThreshold = 0;
         float fEn = 5.5;
         
        
         m_upModule->WriteEnergyThreshold(nThreshold,fEn);
         
        vector<char> vchRefData = {0x00,0xf0,0x33,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x30,0x00,0x9f,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0xa0,0x00,0x19,0x3f,0xed,0x30,0x9e,0x21,0x7f,0xe0
                                 ,0x00,0x47,0x9b,0x40,0x17,0x00,0x06,0x65,0x9f,0x41,0x59,0x3e,0x9f,0x4f
                                 ,0xa7,0xd3,0xe9,0xf4,0xfa,0x09,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xf0
                                 ,0x34,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x30,0x00,0x9f,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0xa0,0x00,0x19,0x3f,0xea,0xad,0xde,0x20,0x3f,0xe0,0x00,0x47
                                 ,0x9b,0x40,0x19,0x00,0x06,0x65,0x9f,0x41,0x59,0x3e,0x9f,0x4f,0xa7,0xd3
                                 ,0xe9,0xf4,0xfa,0x09,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x35,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30
                                 ,0x00,0x9f,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0xa0,0x00,0x19,0x3f,0xec,0x6c,0x9e,0x20,0x3f,0xe0,0x00,0x47,0x9b,0x40
                                 ,0x18,0x40,0x06,0x65,0x9f,0x41,0x59,0x3e,0x9f,0x4f,0xa7,0xd3,0xe9,0xf4
                                 ,0xfa,0x09,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x36,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x9f
                                 ,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa0,0x00
                                 ,0x19,0x3f,0xe8,0x6b,0x1e,0x1e,0x7f,0xe0,0x00,0x47,0x9b,0x40,0x18,0x00
                                 ,0x06,0x65,0x9f,0x41,0x59,0x3e,0x9f,0x4f,0xa7,0xd3,0xe9,0xf4,0xfa,0x09
                                 ,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x37,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x9f,0x20,0x00
                                 ,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa0,0x00,0x19,0x3f
                                 ,0xee,0x6f,0xde,0x22,0x3f,0xe0,0x00,0x47,0x9b,0x40,0x17,0x00,0x06,0x65
                                 ,0x9f,0x41,0x59,0x3e,0x9f,0x4f,0xa7,0xd3,0xe9,0xf4,0xfa,0x09,0x40,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0xf0,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x9f,0x20,0x00,0x00,0x10
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa0,0x00,0x19,0x3f,0xf1,0xb3
                                 ,0x1e,0x25,0x7f,0xe0,0x00,0x47,0x9b,0x40,0x18,0xc0,0x06,0x65,0x9f,0x41
                                 ,0x59,0x3e,0x9f,0x4f,0xa7,0xd3,0xe9,0xf4,0xfa,0x09,0x40,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0xf0,0x39,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x9f,0x20,0x00,0x00,0x10,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0xa0,0x00,0x19,0x3f,0xec,0xef,0x1e,0x21
                                 ,0xff,0xe0,0x00,0x47,0x9b,0x40,0x1b,0x00,0x06,0x65,0x9f,0x41,0x59,0x3e
                                 ,0x9f,0x4f,0xa7,0xd3,0xe9,0xf4,0xfa,0x09,0x40,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0xf0,0x3a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x30,0x00,0x9f,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0xa0,0x00,0x19,0x3f,0xea,0xeb,0x9e,0x1f,0x7f,0xe0
                                 ,0x00,0x47,0x9b,0x40,0x18,0x80,0x06,0x65,0x9f,0x41,0x59,0x3e,0x9f,0x4f
                                 ,0xa7,0xd3,0xe9,0xf4,0xfa,0x09,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xf0
                                 ,0x3b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x30,0x00,0x9f,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0xa0,0x00,0x19,0x3f,0xe7,0xab,0xde,0x20,0x3f,0xe0,0x00,0x47
                                 ,0x9b,0x40,0x18,0x40,0x06,0x65,0x9f,0x41,0x59,0x3e,0x9f,0x4f,0xa7,0xd3
                                 ,0xe9,0xf4,0xfa,0x09,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x3c,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30
                                 ,0x00,0x9f,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0xa0,0x00,0x19,0x3f,0xea,0xab,0x9e,0x1f,0x7f,0xe0,0x00,0x47,0x9b,0x40
                                 ,0x19,0xc0,0x06,0x65,0x9f,0x41,0x59,0x3e,0x9f,0x4f,0xa7,0xd3,0xe9,0xf4
                                 ,0xfa,0x09,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x3d,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x9f
                                 ,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa0,0x00
                                 ,0x19,0x3f,0xec,0xaf,0x9e,0x21,0x7f,0xe0,0x00,0x47,0x9b,0x40,0x16,0x40
                                 ,0x06,0x65,0x9f,0x41,0x59,0x3e,0x9f,0x4f,0xa7,0xd3,0xe9,0xf4,0xfa,0x09
                                 ,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x3e,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00,0x9f,0x20,0x00
                                 ,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xa0,0x00,0x19,0x3f
                                 ,0xea,0x2c,0x9e,0x1f,0x7f,0xe0,0x00,0x47,0x9b,0x40,0x18,0x40,0x06,0x65
                                 ,0x9f,0x41,0x59,0x3e,0x9f,0x4f,0xa7,0xd3,0xe9,0xf4,0xfa,0x09,0x40,0x00
                                 ,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();
        // cout<<"energy:";
        
        //     for(int i=0;i<vchData.size();i++)
        //         printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
    }
    
    void ModuleTest::TestReadOutMode()
    {}
    
    void ModuleTest::TestNetworkMode()
    {}
    
    void ModuleTest::TestUDPMACADDress()
    {
        m_spNetImp->ClearData();
        
        m_upModule->WriteUDPMACAddress(0,m_vstrMAC[0]);
        vector<char> vchRefData = {0x00,0xf0,0x54,0x90,0xb1,0x1c,0x3a,0x2c,0xd7,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x55,0x00,0x0c,0xf1
                                 ,0xf4,0xb0,0x4d,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();
        // cout<<"MCA1:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

       CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));

        m_spNetImp->ClearData();
        
        m_upModule->WriteUDPMACAddress(1,m_vstrMAC[1]);
        vchRefData = {0x00,0xf0,0x56,0xb8,0xca,0x3a,0xee,0x6b,0xa7,0x00,0x00,0x00,0x00,0x00
                    ,0x00,0x00,0x00,0xf0,0x57,0x00,0x0c,0xf1,0xf4,0xb0,0x4d,0x00,0x00
                    ,0x00,0x00,0x00,0x00,0x00};
        vchData = m_spNetImp->GetData();
        // cout<<"MCA2:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

       CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
  
    }
    
    void ModuleTest::TestUDPIP()
    {
         m_spNetImp->ClearData();
        
        m_upModule->WriteUDPIP(0,m_vstrIP[0]);
        vector<char> vchRefData = {0x00,0xf0,0x58,0xc4,0xfe,0x01,0x04,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0
                                 ,0x59,0xc4,0xfe,0x01,0x29,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();
        // cout<<"IP1:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));

        m_spNetImp->ClearData();
        
        m_upModule->WriteUDPIP(1,m_vstrIP[1]);
        vchRefData = {0x00,0xf0,0x5a,0xc4,0xfe,0x03,0x07,0x00,0x00,0x00,0x00
                    ,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x5b,0xc4,0xfe,0x03
                    ,0x29,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        vchData = m_spNetImp->GetData();
        // cout<<"IP2:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
  
    }
    
    void ModuleTest::TestUDPPorts()
    {
        m_spNetImp->ClearData();
        m_upModule->WriteUDPPorts(0,m_vushPort);
        vector<char> vchRefData = {0x00,0xf0,0x5c,0x10,0xe0,0x10,0xe1,0x11,0x46
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();
        // cout<<"port1:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));

        m_spNetImp->ClearData();
        
        m_upModule->WriteUDPPorts(1,m_vushPort);
        vchRefData = {0x00,0xf0,0x5d,0x10,0xe0,0x10,0xe1,0x11,0x46
                    ,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        vchData = m_spNetImp->GetData();
        // cout<<"port2:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
  
    }
    
    void ModuleTest::TestReset()
    {}

    void ModuleTest::TestStartFastImaging()
    {
        m_spNetImp->ClearData();
        
        m_upModule->StartFastImaging();
        
        vector<char> vchRefData = {0x00,0xf0,0x32,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x47,0x00,0x00,0x30
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0xf0,0x46,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0xf0,0x49,0x03,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0
                                 ,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0xf0,0x02,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x00
                                 ,0x1f,0x20,0x00,0x00,0x10,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0xa0,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();
        // cout<<"start:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
    }
    
    void ModuleTest::TestStopFastImaging()
    {
         m_spNetImp->ClearData();
        
        m_upModule->StopFastImaging();
        
        vector<char> vchRefData = {0x00,0xf0,0x48,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x4a,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0xf0,0x48,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
                                 ,0x00,0x00,0x00,0x00};
        vector<char> vchData = m_spNetImp->GetData();
        // cout<<"stop:";
        
        // for(int i=0;i<vchData.size();i++)
        //     printf("0x%02x,", (unsigned char)vchData[i]);

        CPPUNIT_ASSERT(m_upCheckEqual->CheckEqualityVecChar(vchData,vchRefData));
    }
    
    bool ModuleTest::ReadConfig(bool bSwitchMode, string strOpMode)
    {
        LOG_TRACE(__FUNCTION__);
        
        //destination port No for CH1
        m_upConfig->LoadLocalConfig(bSwitchMode, strOpMode);
        m_bMultiLink = m_upConfig->GetMultilink();

        m_upConfig->GetUDPConfig(m_vstrMAC,m_vstrIP,m_vushPort);
        m_upConfig->GetTCPConfig(m_strTCPIPAddress,m_shTCPPortNo);

        m_upConfig->GetChipConfig(m_vshCurrentChips,m_vstChipData);
        m_strOperationMode = m_upConfig->GetOperationMode();

        m_strModuleID = m_upConfig->GetModuleName();
        m_stDetData = m_upConfig->GetDetConfigData();
    }
    
}
